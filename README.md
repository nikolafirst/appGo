# Урок 01

Это домашнее задание является началом серии заданий, в рамках которых мы будем разрабатывать простое микросервисное приложение. На самом деле, оно будет скорее сервисным, поскольку все микросервисы будут находиться в одной кодовой базе для удобства. 

В реальных проектах такое расположение микросервисов не всегда применимо. Наша основная цель - создать работающую версию приложения, научиться работать с несколькими базами данных и, возможно, разработать простой RESTful API.

В качестве примера мы возьмем URL-менеджер, который мы разрабатывали на третьем семинаре. Теперь мы хотим адаптировать этот сервис для работы с несколькими пользователями и попробовать применить подход микросервисов.

Ваши задачи на этом этапе:

1. Запуск баз данных: Вам необходимо запустить базы данных PostgreSQL и MongoDB. Это можно сделать с помощью Docker, как описано в лекции, или любым другим удобным способом.
2. Настройка конфигурации: Обратите внимание на пакет env/config, где настраивается приложение. Убедитесь, что настройки портов, пользователей и паролей для ваших баз данных соответствуют используемым в конфигурации. Если необходимо, настройте переменные окружения согласно вашей конфигурации.
3. Создание миграций: Ознакомьтесь с процессом создания миграций. Миграции уже созданы и находятся в папке migrations. 

Для применения миграций к базе данных PostgreSQL используйте инструмент migrate:

```shell
migrate -source file:///path/to/migrations/migrations -database "postgres://localhost:5432/users?sslmode=disable&user=postgres&password=postgres" up
```

Обратите внимание, что путь к папке с миграциями и параметры подключения к базе данных могут отличаться. Если возникают сложности с использованием инструмента миграции, создайте базу данных users вручную, используя файлы из папки с миграциями.

4. Доработка методов: Вам необходимо дописать нереализованные методы в пакетах database/users и database/links. Вы можете изменять структуру проекта, композицию и конфигурацию по своему усмотрению, однако все дальнейшие инструкции будут основываться на текущей структуре проекта.

## Пояснения 
Это задание поможет вам познакомиться с файлами и структурой проекта, а также понять, как осуществляется его конфигурация. 

В последующих заданиях мы будем развивать эту структуру. В отличие от предыдущих заданий, я буду предоставлять базовое решение, которое не охватывает все возможные сценарии и граничные случаи.

Это позволит нам продвигаться вперед, не застревая на деталях. Однако для достижения качественных результатов вам потребуется более детально проработать решения самостоятельно. Задания со звездочкой больше не будут предоставляться, но вы можете усложнить проект самостоятельно, добавив новые функции или улучшив архитектуру. Успехов в работе!

# Урок 2

### Описание
Продолжаем развивать наше зарождающееся микросервисное приложение.
В этом задании мы добавим новый сервис с публичным контрактом и свяжем его с двумя нашими микросервисами посредством 
gRPC.

Самая главная задача разберитесь с тем, что уже есть в репозитории. Я создал для вас простой контракт для openapi и 
gRPC. Также я сделал Makefile, на семинаре работали с ним немного.

### Про утилиты
Напомню, установите команду make. Чтобы запускать рецепты Makefile нужно всего лишь написать
```shell
make build
```

или

```shell
make docker
```

Некоторые рецепты вам здорово упростят жизнь. Например 
```shell
make generate
```

Перегенерирует вам gRPC или openapi каркасы если вы внесли в них изменения. Я стараюсь контракты описывать за вас, 
чтобы возникло меньше сложностей. 

Для проверки работы сервиса можно воспользоваться утилитой [grpcui](https://github.com/fullstorydev/grpcui)
В коде сервиса указан запуск reflection api, чтобы эта утилитка могла работать. Она работает через web gui.

Для проверки http воспользуйтесь утилитой [curl](https://curl.se/download.html) или [postman](https://www.postman.
com/downloads/)

### Важная информация
Еще раз ознакомьтесь с проектом, посмотрите на новые файлы и далее приступайте к изучению, что мы хотим сделать в 
этом задании. Сразу хочется сказать, что это учебный пример, и мы возвращаем модель с паролем. Я предлагаю просто 
возвращать модель с пустой строкой. В реальном апи нужно возвращать другую модель, обрезанную. Также мы пока не 
учитываем, что пароли нужно хешировать и хранить в хешированном виде. Позже мы вернемся к этому.


### Что нового в проекте

Итак у нас появляется третий сервис это апи гейтвей. Более подробно об этом паттерне я расскажу на 3ей лекции. Мы 
будем реализовывать его самостоятельно, хотя существуют и готовые решения для подобных задач.

Идея следующая:
* http запрос приходит на api-gw на определенный хэндлер
* Далее с помощью gRPC клиента соответствующего мы делаем запрос в сервис users-srv
  или links-srv и получаем ответ
* Упаковываем ответ в модель openapi и возвращаем клиенту.
* Пока на этом все.


## Что нужно реализовать?

* Хэндлеры api-gw которые лежат в internal/apigw/v1 . Логика реализуется в файлах links.go и users.go. Это хэндлеры 
  согласно спецификации. Они должны получать запрос и перенаправлять его в нужный сервис через grpc с помощью grpc 
  клиента, который туда уже проброшен. Вы увидите у него соответствующие методы. 
* Хэндлеры grpc сервера для users и links, которые лежат по пути internal/link/linkgrpc и internal/user/usergrpc . 
  Тут соответственно мы должны получить запрос и с помощью репозиториев usersRepository или linksRepository 
  создавать, получать,обновлять или удалять сущности User, Link. Сам код репозитория уже написан. Если вы видите 
  ошибки не стисняйтесь их исправлять и говорить мне. Я исправлю в шаблоне.

## Как все проверить

Вы должны делать запросы на наше апи по адресу http://localhost:8080/api/v1 на разные ресурсы и у 
вас все должно работать.
1) Запустить отдельно все 3 сервиса. Убедитесь, что сервис стартовал и вывел свой порт
2) Можно отлаживать grpc с помощью grpcui там веб интерфейс все интуитивно понятно
3) Делать запросы в api-gw по адресу http://localhost:8080/api/v1/users например
4) curl -vvv -XGET http://localhost:8080/api/v1/users/58a06aa0-633e-45bd-976a-c5171413b3ea должен вернуть 
   пользователя с id 58a06aa0-633e-45bd-976a-c5171413b3ea. Для этого его сначала нужно создать через POST

Через api-gw вы должны уметь
* Создавать пользователя, получать пользователя по id, удалять пользователя, обновлять пользователя, отображать всех 
  пользователей
* Создавать ссылку, получать ссылку по id, удалять ссылку, обновлять ссылку, отображать все ссылки
* Когда запрос приходит на api-gw он должен через клиент gRPC делать соответствующие запросы на нужный сервис по 
  gRPC, получать ответ, преобразовывать ответ и отдавать по HTTP

### Коммуникация
Если что-то не получается коммуницируйте в группе и делитесь знаниями. Это ускоряет прогресс всей группы

### Документация

Пока в папке docs лежит только упрощенная схема текущего приложения, которая будет обновляться

# Урок 3


### Описание
Продолжаем развивать написанное приложения. Теперь нам нужно добавить работу с очередью в нашем приложении. 


### Идея новой версии
Мы хотим быстро создать новый объект ссылки, но в фоне сходить по адресу и распарсить некоторые интересные теги, 
например теги, description, title. Эти новые данные нужно добавить или обновить в базе. Теги нужно добавить к старым,
title заменить если он не пустой. Description пока проигнорировать.

### Что нужно сделать
* Обратите внимание на links-srv там мы в отдельной горутине вызываем e.LinkUpdater.Run(ctx).
* После создания ссылки в internal/link/linkgrpc CreateLink нужно отправить сообщение в очередь с id созданной ссылки.
* В internal/link/stories/link-updater нужно слушать сообщения из очереди с id ссылки. После получения сообщения 
  нужно получить объект ссылки из базы данны. Потом вызывать пакет pkg/scrape и передать туда url ссылки. Пакет 
  попробует распарсить немного данных по ссылке. Если получилось распарсить новые данные, то добавить их в объект 
  ссылки и обновить итоговый объект в базе данных. Приоритет Title отдать тому, что получаем из scrape.

  # Урок 4

## Описание
В этом задании вам нужно подвести итог нашего приложения. К сожалению мы не можем рассмотреть множество тем, которые 
могли бы сделать наш проект более продакшен реди. Мы сосредоточились на сетевой связности и некоторых асинхронных 
функциях.

Что мы не можем разобрать в наших дз и семинарах. Это тему авторизации, нормального использования observability и DDD.
Вы можете самостоятельно разобрать эти темы и, например добавить такие вещи как хэширование паролей через bcrypt и 
организацию сессий. Сессии можно хранить в redis. Можно пойти по пути генерации jwt токенов.

* Во-первых, вам нужно залогировать ошибки там где это уместно. Сделать это нужно в http хэндлерах api gw. В grpc это 
делать не нужно. 
* Во-вторых Вам нужно продемонстрировать ваше умение писать тесты. Нужно написать несколько тестов

## Про тесты
Вы можете сделать это несколькими путями. Вы можете
написать тесты на хэндлеры в api gw с помощью httptest. Достаточно написать несколько тестов на POST, DELETE
операции. Вам может понадобится использовать mockgen для мокания grpc client. Вместо mockgen также можете
использовать собственный stub объект. Для этого вам нужно написать собственную реализацию интерфейсов grpc
клиентов.В реализации можете возвращать например фейковые данные. 